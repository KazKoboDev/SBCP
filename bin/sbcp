#!/usr/bin/env ruby

require 'optparse'
require 'highline'
require_relative '../lib/sbcp/version'

o = OptionParser.new do |opts|
	opts.banner = 'Usage: sbcp [options]'

	# This starts SBCP and creates the underlying daemon process.
	# The daemon process is responsible for maintaining the server.
	# There are two modes, Command Line Interface and Graphical User Interface.
	# CLI mode disables the web server to improve performance.

	opts.on('-s', '--start [MODE]', 'Starts SBCP in either CLI or GUI mode (Default: CLI)') do |mode|
		mode = 'CLI' if mode == nil
		case mode.upcase
		when 'CLI'
			require_relative '../lib/sbcp/daemon'
			SBCP::Daemon.run
			puts 'The control panel has been started in CLI mode.'
		when 'GUI'
			puts 'Currently unsupported.'
			#require '../lib/sbcp'
			#SBCP::Panel.run!
			#puts "The control panel has been started in GUI mode."
			#puts "Access the GUI at <ipaddress>:4567 in your web browser."
		else
			puts 'Please provide either CLI or GUI as an arguement.'
		end
	end

	# Attempts to gracefully stop the server without fully shutting it down.
	# This may not always be successful, as Starbound is sometimes unreceptive to kill signals.

	opts.on('-r', '--restart', 'Gracefully restarts the Starbound server') do

	end

	# This kills the server process almost immediately.
	# This just stops it cold in it's tracks, so it's possible to lose information stored in memory.

	opts.on('-R', '--reboot', 'Forcibly restarts the Starbound server') do
		if @cli.agree('This will forcibly restart the server. Some data may be lost as a result. Are you sure? (y/n)') then
			# restart server
		else
			puts 'Force restart aborted.'
		end
	end

	# Same as the graceful restart option, only the server doesn't come back automatically.
	# We create a temporary file to indicate that we don't want the server to restart.
	# The temporary file is removed when we call file.unlink

	opts.on('-g', '--grace', 'Gracefully stops the Starbound server') do
		require 'tempfile'
		puts 'Attempting to gracefully stop the Starbound server...'
		begin
			file = Tempfile.new('sb-shutdown')
			pid = `pidof starbound_server`
			if not pid.empty?
				system("kill -15 #{pid.to_i}")
				sleep 5
				abort('Unable to gracefully stop the server. Force may be neccesary.') if not `pidof starbound_server`.empty?
				puts 'The Starbound server has been successfully stopped.'
			else
				abort('Unable to locate the Starbound server process ID. Is it running?')
			end
		ensure
			file.close
			file.unlink
		end
	end

	# Same as the force restart option, without the server coming back automatically.

	opts.on('-K', '--kill', 'Forcibly stops the Starbound server') do
		 if @cli.agree('This will forcibly stop the server. Some data may be lost as a result. Are you sure? (y/n)') then
			require 'tempfile'

		else
			puts 'Force stop aborted.'
		end
	end

	# Allows an admin to kick a player.
	# UUIDs can be spoofed and names can be changed, so IP is the most reliable. (Although, proxies can bypass this.)
	# There will be support for Steam IDs if/when Starbound supports them.

	opts.on('-k', '--kick TYPE', [:uuid, :name, :ip], 'Kicks a specified player by either UUID, Name, or IP') do |type|
		
	end

	# Same as the kick command, except for a specified time period or permanently.
	# Can be reverse with the unban command.

	opts.on('-b', '--ban TYPE', [:uuid, :name, :ip], 'Bans a specified player by either UUID, Name, or IP') do |type|

	end

	# Removes a previously assigned ban on a player based on criteria.
	# It will return an error if the specified critera doesn't exist.

	opts.on('-u', '--unban TYPE', [:uuid, :name, :ip], 'Unbans a specified player by either UUID, Name, or IP') do |type|

	end

	# Allows an admin to easily grab the most recent information.
	# Supports up to the last 100 lines.

	opts.on('-l', '--list TYPE', [:bans, :connections, :logs], 'Lists the last X lines of the specified data type. (bans, connections, or logs)') do |type|

	end

	# This command creates a full backup of all Starbound and SBCP data.
	# This includes: Starbound world files, logs files, and the SBCP database.

	opts.on('-B', '--backup', 'Creates a backup of all Starbound worlds, logs, and SBCP data') do
		if @cli.agree("Are you sure? This will create a backup of all Starbound and SBCP data.\nIf the Starbound server is running, it may experience brief sluggishness.") then
			require_relative '../lib/sbcp/backup'
			SBCP::Backup.create_backup
		else
			puts 'Backup aborted.'
		end
	end

	# Stops the SBCP process as gently as possible.
	# It won't work if Starbound is running, so stop the Starbound server first.

	opts.on('-e', '--exit', 'Gracefully stops SBCP') do
		puts 'Are you sure? This will gracefully stop the control panel.'
		puts 'If the Starbound server is running, you must stop it before this command will work.'
		puts "Type 'yes' to continue."
		if gets.chomp == 'yes' then
			# stop SBCP
		else
			puts 'The control panel was not stopped.'
		end
	end

	# Sometimes things just need to be stopped forcibly.
	# This command does that.
	# Data in memory may be lost.
	# Kills both SBCP and the Starbound server, if running.

	opts.on('-a', '--abort', 'Forcibly stops SBCP') do
		puts 'Are you sure? This will forcibly stop the control panel. Some data may be lost as a result.'
		puts "Type 'yes' to continue."
		if gets.chomp == 'yes' then
			# kill sbcp
		else
			puts 'The control panel was not aborted.'
		end
	end

	# Opens the config menu.
	# What else is there to say?

	opts.on_tail('-c', '--config', 'Opens the config menu') do
		require 'yaml'
		config_menu(:main)
	end

	# This sets SBCP up for proper usage.
	# Ideally, only run once.

	opts.on_tail('-S', '--setup', 'Performs first time setup') do
		require 'yaml'
		require 'fileutils'
		config = YAML.load_file(File.expand_path('../../config.yml', __FILE__))
		@cli.say('Are you sure you want to run the first-time setup? (y/n)')
		@cli.say("If this is your first time running setup, type 'yes' to continue.")
		response = @cli.agree("Otherwise, type 'no' to cancel.")
		if response # If response is true, continue
			#IO.popen('bundle install') do |output| 
			#	while line = output.gets
			#		puts line
			#	end 
			#end

			# First, we must attempt to locate where Starbound is installed.
			# This performs a recursive search on the OS for a folder named 'giraffe_storage'
			@cli.newline
			@cli.say('SBCP is starting up...')
			@cli.say('SBCP is attempting to automatically locate Starbound...')
			result = Dir.glob('/**/*/giraffe_storage')
			if result.empty?
				@cli.say('Unable to locate the Starbound installation directory.')
				a = ''
				until Dir.exist?(a) && Dir.exist?(a + '/giraffe_storage')
					a = @cli.ask("Please locate the directory manually and enter it below.\n> ")
					@cli.say('This dirctory does not exist or is not a Starbound installation. Try again.') if not Dir.exist?(a) && Dir.exist?(a + '/giraffe_storage')
				end
				config['starbound_directory'] = a
			else
				if result.count > 1
					@cli.say('SBCP encountered multiple possible directories.')
					answer = @cli.choose do |menu|
						menu.prompt = "Please select a directory\n> "
						result.each do |dir|
							dir = dir.split("/")[0..3].join("/") 
							menu.choice(dir) { config['starbound_directory'] = dir }
						end
					end
					@cli.say("Starbound installation directory set to \"#{config['starbound_directory']}\"")
				else
					r = result.first.split("/")[0..3].join("/") 
					@cli.say('SBCP successfully located the Starbound installation directory at:')
					@cli.say("\"#{r}\"")
					config['starbound_directory'] = r
				end
			end
			root = config['starbound_directory']

			@cli.newline
			@cli.say("Welcome to SBCP.")
			@cli.say("You can change any options later by running the config command. (sbcp -c)")
			if @cli.agree("Would you like to skip setup and just use SBCP's default settings? (See README) (y/n)")
				# So we're running with the defaults. Let's get 'em setup!
				FileUtils.mkdir "#{root}/sbcp" if not Dir.exist?("#{root}/sbcp")
				FileUtils.mkdir "#{root}/sbcp/backups" if not Dir.exist?("#{root}/sbcp/backups")
				FileUtils.mkdir "#{root}/sbcp/logs" if not Dir.exist?("#{root}/sbcp/logs")
				config['backup_directory'] = "#{root}/sbcp/backups"
				config['logs_directory'] = "#{root}/sbcp/logs"
			else
				# Let's run through some of the custom config options.
				# TODO
			end

			# Create the plugins directory and readme
			FileUtils.mkdir_p "#{root}/sbcp/plugins" if not Dir.exist?("#{root}/sbcp/plugins")
			File.write("#{root}/sbcp/plugins/README.txt", "You can extend or change SBCP's behavior by writing your own Ruby plugins and placing them here.\nCheck the README on GitHub for more information.")

			# We save everything back to the config file at the end.
			File.write(File.expand_path('../../config.yml', __FILE__), config.to_yaml)

			@cli.newline
			@cli.say('SBCP has been configured successfully.')
			@cli.say('Type sbcp -h for a list of commands.')
		end
	end

	# Displays help.

	opts.on_tail('-h', '--help', 'Show this message') do
		puts opts
		exit
	end
end

def config_menu(menu)
	case menu
	when :main
		answer = @cli.choose do |menu|
			menu.prompt = "Please select a menu option\n> "
			@cli.say("SBCP Configuration Menu")
			menu.choice(:Backups) { config_menu(:backups) }
			menu.choice(:Logs) { config_menu(:logs) }
			menu.choice(:Restarts) { config_menu(:restarts) }
		end
	when :backups
	when :logs
	when :restarts
	end
end

ARGV << '-h' if ARGV.empty? # Displays help if no arguements given.
@cli = HighLine.new # Initialize highline object
begin o.parse!
rescue OptionParser::MissingArgument => e
	puts e
	puts 'Please provide an arguement.'
	puts "Example: sbcp #{e.to_s.split(' ').last} <arg>"
rescue OptionParser::InvalidArgument => e
	puts e
	flag = e.to_s.split(' ')[2]
	case flag
	when '-k'
		puts 'Please provide uuid, name, or ip as an arguement.'
		puts "Example: sbcp #{flag} uuid"
	when '-b'
		puts 'Please provide uuid, name, or ip as an arguement.'
		puts "Example: sbcp #{flag} name"
	when '-u'
		puts 'Please provide uuid, name, or ip as an arguement.'
		puts "Example: sbcp #{flag} ip"
	when '-l'
		puts 'Please provide bans, connections, or logs as an arguement.'
		puts "Example: sbcp #{flag} bans"
	end
rescue OptionParser::InvalidOption => e
	puts e
	puts o 
	exit 1
end