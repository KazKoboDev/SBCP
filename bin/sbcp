#!/usr/bin/env ruby

# SBCP - Starbound Server Management Solution for Linux Servers
# Copyright (C) 2016 Kazyyk

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require 'optparse'
require 'highline'
require_relative '../lib/sbcp/version'

o = OptionParser.new do |opts|
	opts.banner = 'Usage: sbcp [options]'

	# This starts SBCP and creates the underlying daemon process.
	# The daemon process is responsible for maintaining the server.
	# There are two modes, Command Line Interface and Graphical User Interface.
	# CLI mode disables the web server to improve performance.

	opts.on('-s', '--start [MODE]', 'Starts SBCP in either CLI or GUI mode (Default: CLI)') do |mode|
		mode = 'CLI' if mode == nil
		case mode.upcase
		when 'CLI'
			@cli.say('The control panel has been started in CLI mode.')
			@cli.say('The Starbound server has also been started.')
			require_relative '../lib/sbcp/daemon'
			SBCP::Daemon.run
		when 'GUI'
			abort('Currently unsupported.')
			#require '../lib/sbcp'
			#SBCP::Panel.run!
			#puts "The control panel has been started in GUI mode."
			#puts "Access the GUI at <ipaddress>:4567 in your web browser."
		else
			@cli.say('Please provide either CLI or GUI as an arguement.')
		end
	end

	# Attempts to gracefully stop the server without fully shutting it down.
	# This may not always be successful, as Starbound is sometimes unreceptive to kill signals.

	opts.on('-r', '--restart', 'Gracefully restarts the Starbound server') do
		if @cli.agree('This will attempt to gracefully restart the server. Are you sure? (y/n)') then
			@cli.say('Attempting to gracefully restart the server...')
			pid = `pidof starbound_server`
			if not pid.empty?
				system("kill -15 #{pid.to_i}")
				time = Time.now
				diff = 0
				until `pidof starbound_server`.empty? || diff >= 5
					sleep 1
					diff = Time.now - time
				end
				abort('Unable to stop the server for restart. Reboot command may be required.') if not `pidof starbound_server`.empty?
				@cli.say('The Starbound server has been successfully stopped and will restart automatically.')
			else
				abort('Unable to locate the Starbound server process ID. Is it running?')
			end
		else
			@cli.say('Graceful restart aborted.')
		end
	end

	# This kills the server process almost immediately.
	# This just stops it cold in it's tracks, so it's possible to lose information stored in memory.

	opts.on('-R', '--reboot', 'Forcibly restarts the Starbound server') do
		if @cli.agree('This will forcibly restart the server. Some data may be lost as a result. Are you sure? (y/n)') then
			@cli.say('Attempting to forcefully reboot the server...')
			pid = `pidof starbound_server`
			if not pid.empty?
				system("kill -9 #{pid.to_i}")
				time = Time.now
				diff = 0
				until `pidof starbound_server`.empty? || diff >= 5
					sleep 1
					diff = Time.now - time
				end
				abort('Unable to forcefully reboot the server. Try again?') if not `pidof starbound_server`.empty?
				@cli.say('The Starbound server has been successfully stopped and will restart automatically.')
			else
				abort('Unable to locate the Starbound server process ID. Is it running?')
			end
		else
			@cli.say('Force restart aborted.')
		end
	end

	# Same as the graceful restart option, only the server doesn't come back automatically.
	# We create a temporary file to indicate that we don't want the server to restart.
	# The temporary file is removed when we call file.unlink

	opts.on('-g', '--grace', 'Gracefully stops the Starbound server') do
		if @cli.agree('This will attempt to gracefully stop the server. Are you sure? (y/n)') then
			require 'tempfile'
			@cli.say('Attempting to gracefully stop the Starbound server...')
			begin
				file = Tempfile.new('sb-shutdown')
				pid = `pidof starbound_server`
				if not pid.empty?
					system("kill -15 #{pid.to_i}")
					time = Time.now
					diff = 0
					until `pidof starbound_server`.empty? || diff >= 5
						sleep 1
						diff = Time.now - time
					end
					abort('Unable to gracefully stop the server. Force may be neccesary.') if not `pidof starbound_server`.empty?
					@cli.say('The Starbound server has been successfully stopped.')
				else
					abort('Unable to locate the Starbound server process ID. Is it running?')
				end
			ensure
				file.close
				file.unlink
			end
		else
			@cli.say('Server shutdown aborted.')
		end
	end

	# Same as the force restart option, without the server coming back automatically.

	opts.on('-K', '--kill', 'Forcibly stops the Starbound server') do
		 if @cli.agree('This will forcibly stop the server. Some data may be lost as a result. Are you sure? (y/n)') then
			require 'tempfile'
			@cli.say('Attempting to forcefully stop the Starbound server...')
			begin
				file = Tempfile.new('sb-shutdown')
				pid = `pidof starbound_server`
				if not pid.empty?
					system("kill -9 #{pid.to_i}")
					time = Time.now
					diff = 0
					until `pidof starbound_server`.empty? || diff >= 5
						sleep 1
						diff = Time.now - time
					end
					abort('Unable to forcefully stop the server. Try again?') if not `pidof starbound_server`.empty?
					@cli.say('The Starbound server has been successfully stopped.')
				else
					abort('Unable to locate the Starbound server process ID. Is it running?')
				end
			ensure
				file.close
				file.unlink
			end
		else
			@cli.say('Force stop aborted.')
		end
	end

	# Allows an admin to kick a player.
	# UUIDs can be spoofed and names can be changed, so IP is the most reliable. (Although, proxies can bypass this.)
	# There will be support for Steam IDs if/when Starbound supports them.

	opts.on('-k', '--kick TYPE', [:uuid, :name, :ip], 'Kicks a specified player by either UUID, Name, or IP') do |type|
		@cli.say('This feature will be added later.')
	end

	# Same as the kick command, except for a specified time period or permanently.
	# Can be reverse with the unban command.

	opts.on('-b', '--ban TYPE', [:uuid, :name, :ip], 'Bans a specified player by either UUID, Name, or IP') do |type|
		@cli.say('This feature will be added later.')
	end

	# Removes a previously assigned ban on a player based on criteria.
	# It will return an error if the specified critera doesn't exist.

	opts.on('-u', '--unban TYPE', [:uuid, :name, :ip], 'Unbans a specified player by either UUID, Name, or IP') do |type|
		@cli.say('This feature will be added later.')
	end

	# Allows an admin to easily grab the most recent information.
	# Supports up to the last 100 lines.

	opts.on('-l', '--list TYPE', [:bans, :connections, :logs], 'Lists the last X lines of the specified data type. (bans, connections, or logs)') do |type|
		@cli.say('This feature will be added later.')
	end

	# This command creates a full backup of all Starbound and SBCP data.
	# This includes: Starbound world files, logs files, and the SBCP database.

	opts.on('-B', '--backup TYPE', [:starbound, :sbcp, :full],'Creates a backup of the specified data. (starbound, sbcp, or full)') do |type|
		if @cli.agree("Are you sure? This will start the backup process.\nIf the Starbound server is running, it may experience brief sluggishness.") then
			require_relative '../lib/sbcp/backup'
			SBCP::Backup.create_backup(type)
			@cli.say('Backup has completed successfully.')
		else
			@cli.say('Backup aborted.')
		end
	end

	# Stops the SBCP process as gently as possible.
	# It won't work if Starbound is running, so stop the Starbound server first.

	opts.on('-e', '--exit', 'Gracefully stops SBCP') do
		@cli.say("This feature is only used in GUI mode. GUI mode is not yet implemented.")
		@cli.say("In CLI mode, stopping Starbound will automatically stop SBCP.")
	end

	# Kills both SBCP and the Starbound server, if running.
	# This command needs work. It doesn't always work properly.
	# Usually, the starbound process has to be killed first.
	# After that, SBCP usually closes on it's own... making this command moot.

	opts.on('-a', '--abort', 'Forcibly stops SBCP') do
		if @cli.agree('This will attempt to forcibly stop the control panel. Some data may be lost as a result. Are you sure? (y/n)') then
			pid = `pidof starbound_server`
			if not pid.empty?
				system("kill -9 #{pid.to_i}")
				time = Time.now
				diff = 0
				until `pidof starbound_server`.empty? || diff >= 5
					sleep 1
					diff = Time.now - time
				end
				abort('Unable to forcfully close Starbound. Try closing it separately?') if not `pidof starbound_server`.empty?
			end
			if not Dir.glob('/tmp/sbcp_daemon-pid*').empty?
				pid_file = Dir.glob('/tmp/sbcp_daemon-pid*').first
				pid = File.read(pid_file)
				system("kill -9 #{pid.to_i}")
				time = Time.now
				diff = 0
				until `ps -p #{pid.to_i} -o comm=`.empty? || diff >= 5
					sleep 1
					diff = Time.now - time
				end
				abort('Unable to forcefully stop the control panel. Try again?') if not `ps -p #{pid.to_i} -o comm=`.empty?
				@cli.say('The control panel has been successfully stopped.')
			else
				@cli.say('Unable to locate the control panel process ID. Is it running?')
			end
		else
			puts 'The control panel was not aborted.'
		end
	end

	# Opens the config menu.
	# What else is there to say?

	opts.on_tail('-c', '--config', 'Opens the config menu') do
		require 'yaml'
		#@cli.say('NOTICE: SBCP must be restarted for any changes to take effect. (GUI mode only)')
		@cli.say('NOTICE: Starbound must be restarted for any changes to take effect.')
		config_menu(:main)
	end

	# This sets SBCP up for proper usage.
	# Ideally, only run once.

	opts.on_tail('-S', '--setup', 'Performs first time setup') do
		require 'yaml'
		require 'fileutils'
		config_file = File.expand_path('../../config.yml', __FILE__)
		config = YAML.load_file(config_file)
		response = @cli.agree('Are you sure you want to run the first-time setup? (y/n)')
		if response # If response is true, continue
			# First, we must attempt to locate where Starbound is installed.
			# This performs a recursive search on the OS for a folder named 'giraffe_storage'
			@cli.newline
			@cli.say('SBCP is starting up...')
			@cli.say('SBCP is attempting to automatically locate Starbound...')
			result = Dir.glob('/**/*/giraffe_storage')
			if result.empty?
				@cli.say('Unable to locate the Starbound installation directory.')
				a = ''
				until Dir.exist?(a) && Dir.exist?(a + '/giraffe_storage') && File.writable?(a)
					a = @cli.ask("Please locate the directory manually and enter it below.\n> ")
					if not Dir.exist?(a) && Dir.exist?(a + '/giraffe_storage')
						@cli.say('Error - This dirctory does not exist or is not a Starbound installation. Try again.')
					elsif not File.writable?(a)
						@cli.say('Error - This dirctory cannot be written to. Check permissions and try again.')
					end
				end
				config['starbound_directory'] = a
			else
				if result.count > 1
					@cli.say('SBCP encountered multiple possible directories.')
					answer = @cli.choose do |menu|
						menu.prompt = "Please select a directory\n> "
						result.each do |dir|
							dir = dir.split("/")[0..3].join("/") 
							menu.choice(dir) { abort('Error - This directory cannot be written to. Check permissions and try again.') if not File.writable?(dir); config['starbound_directory'] = dir }
						end
					end
					@cli.say("Starbound installation directory set to \"#{config['starbound_directory']}\"")
				else
					r = result.first.split("/giraffe_storage").first
					@cli.say('SBCP successfully located the Starbound installation directory at:')
					@cli.say("\"#{r}\"")
					abort('Error - This directory cannot be written to. Check permissions and try again.') if not File.writable?(r)
					config['starbound_directory'] = r
				end
			end
			root = config['starbound_directory']

			@cli.newline
			@cli.say('Welcome to SBCP.')
			@cli.say('You can change any options later by running the config command. (sbcp -c)')
			if @cli.agree("Would you like to skip setup and just use SBCP's default settings? (See README) (y/n)")
				# So we're running with the defaults. Let's get 'em setup!
				FileUtils.mkdir "#{root}/sbcp" if not Dir.exist?("#{root}/sbcp")
				FileUtils.mkdir "#{root}/sbcp/backups" if not Dir.exist?("#{root}/sbcp/backups")
				FileUtils.mkdir "#{root}/sbcp/logs" if not Dir.exist?("#{root}/sbcp/logs")
				config['backup_directory'] = "#{root}/sbcp/backups"
				config['backup_history'] = 90
				config['backup_schedule'] = "hourly"
				config['log_directory'] = "#{root}/sbcp/logs"
				config['log_history'] = 90
				config['log_style'] = "daily"
				config['restart_schedule'] = 4
			else
				# Backup Settings
				@cli.newline
				@cli.say('--- Automatic Backups ---')
				if @cli.agree('Would you like to enable automatic backups?')
					@cli.newline
					@cli.say('--- Backup Directory Location ---')
					answer = ''
					until Dir.exist?(answer) && File.writable?(answer) || answer == 'default'
						answer = @cli.ask('Where would you like backups to be stored? Type "default" to use default.')
						if not Dir.exist?(answer)
							@cli.say('Error - This dirctory does not exist. Try again.') unless answer == 'default'
						elsif not File.writable?(answer)
							@cli.say('Error - This dirctory cannot be written to. Check permissions and try again.')
						end
					end
					if answer == 'default'
						config['backup_directory'] = "#{root}/sbcp/backups"
						FileUtils.mkdir_p "#{root}/sbcp/backups" if not Dir.exist?("#{root}/sbcp/backups")
					else
						config['backup_directory'] = answer
					end

					@cli.newline
					@cli.say('--- Backup Schedule ---')
					answer = @cli.ask('How frequently would you like to take backups (in hours)? Type 0 for on restart.', Integer) { |q| q.in = [0, 1, 2, 3, 4, 6, 8, 12, 24] }
					answer = 'restart' if answer == 0
					answer = 'hourly' if answer == 1
					answer = 'daily' if answer == 24
					config['backup_schedule'] = answer

					@cli.newline
					@cli.say('--- Backup History ---')
					answer = 0
					until answer > 0
						answer = @cli.ask('How long would like to keep the backups (in # of days)?', Integer)
						@cli.say('Value must be greater than zero.') if not answer > 0
					end
					config['backup_history'] = answer
				else
					config['backup_history'] = 'none'
				end
				File.write(config_file, config.to_yaml) # Periodic save

				# Log Settings
				@cli.newline
				@cli.say('--- Log Directory Location ---')
				answer = ''
				until Dir.exist?(answer) && File.writable?(answer) || answer == 'default'
					answer = @cli.ask('Where would you like log files to be stored? Type "default" to use default.')
					if not Dir.exist?(answer)
						@cli.say('Error - This dirctory does not exist. Try again.') unless answer == 'default'
					elsif not File.writable?(answer)
						@cli.say('Error - This dirctory cannot be written to. Check permissions and try again.')
					end
				end
				if answer == 'default'
					config['log_directory'] = "#{root}/sbcp/logs"
					FileUtils.mkdir_p "#{root}/sbcp/logs" if not Dir.exist?("#{root}/sbcp/logs")
				else
					config['log_directory'] = answer
				end

				@cli.newline
				@cli.say('--- Log History ---')
				answer = 0
				until answer > 0
					answer = @cli.ask('How long would you like log files to be kept (in days)?', Integer)
					@cli.say('Value must be greater than zero.') if not answer > 0
				end
				config['log_history'] = answer

				@cli.newline
				@cli.say('--- Log Style ---')
				@cli.say('There are two types of log styles available.')
				@cli.say('Daily: One log file per day. Bigger files, but less of them.')
				@cli.say('Restart: One log file per restart. Smaller files, but more of them.')
				answer = @cli.ask("What kind of log style do you prefer?\n> ") { |q| q.in = ['daily', 'restart'] }
				config['log_style'] = answer
				File.write(config_file, config.to_yaml)

				# Restart Settings
				@cli.newline
				@cli.say('--- Restart Schedule ---')
				answer = @cli.ask('How frequently would you like the Starbound server to restart (in hours)? Type 0 to disable.', Integer) { |q| q.in = [0, 1, 2, 3, 4, 6, 8, 12, 24] }
				answer = 'none' if response == 0
				answer = 'hourly' if response == 1
				answer = 'daily' if response == 24
				config['restart_schedule'] = answer
				File.write(config_file, config.to_yaml)
			end

			# Create the plugins directory and readme
			FileUtils.mkdir_p "#{root}/sbcp/plugins" if not Dir.exist?("#{root}/sbcp/plugins")
			File.write("#{root}/sbcp/plugins/README.txt", "You can override SBCP's behavior by writing your own Ruby plugins and placing them here.\nCheck the README on GitHub for more information.")

			# We save everything back to the config file at the end.
			File.write(File.expand_path('../../config.yml', __FILE__), config.to_yaml)

			@cli.newline
			@cli.say('SBCP has been configured successfully.')
			@cli.say('Type sbcp -h for a list of commands.')
		end
	end

	# Displays help.

	opts.on_tail('-h', '--help', 'Show this message') do
		puts opts
		exit
	end
end

def config_menu(menu)
	config_file = File.expand_path('../../config.yml', __FILE__)
	config = YAML.load_file(config_file)
	case menu
	when :main
		answer = @cli.choose do |menu|
			menu.prompt = "Please select a menu option\n> "
			@cli.say("=== SBCP Configuration Menu ===")
			menu.choice(:General) { config_menu(:general) }
			menu.choice(:Backups) { config_menu(:backups) }
			menu.choice(:Logs) { config_menu(:logs) }
			menu.choice(:Restarts) { config_menu(:restarts) }
			menu.choice(:Exit) { exit }
		end
	when :general
		answer = @cli.choose do |menu|
			menu.prompt = "Please select a menu option\n> "
			@cli.say("=== SBCP General Settings ===")
			menu.choice('Starbound Directory') do
				@cli.choose do |sub_menu|
					sub_menu.prompt = "Please select a menu option\n> "
					@cli.say("=== SBCP Starbound Directory Setting ===")
					@cli.say('Your current starbound directory is:')
					@cli.say("\"#{config['starbound_directory']}\"")
					sub_menu.choice('Keep this directory') { @cli.say('Directory kept.'); config_menu(:general) }
					sub_menu.choice('Change this directory') do
						response = ''
						until Dir.exist?(response) && Dir.exist?(response + '/giraffe_storage') && File.writable?(response)
							response = @cli.ask("Please enter a new directory.\n> ")
							if not Dir.exist?(response) && Dir.exist?(response + '/giraffe_storage')
								@cli.say('Error - This dirctory does not exist or is not a valid starbound installation. Try again.')
							elsif not File.writable?(response)
								@cli.say('Error - This dirctory cannot be written to. Check permissions and try again.')
							end
						end
						config['starbound_directory'] = response
						File.write(config_file, config.to_yaml)
						@cli.say('Changes saved successfully.')
						config_menu(:general)
					end
				end
			end
			menu.choice('Back to Main Menu') { config_menu(:main) }
		end
	when :backups
		@cli.choose do |menu|
			menu.prompt = "Please select a menu option\n> "
			@cli.say("=== SBCP Backup Settings ===")
			menu.choice('Backup Directory') do
				@cli.choose do |sub_menu|
					sub_menu.prompt = "Please select a menu option\n> "
					@cli.say("=== SBCP Backup Directory Setting ===")
					@cli.say('Your current backup directory is:')
					@cli.say("\"#{config['backup_directory']}\"")
					sub_menu.choice('Keep this directory') { @cli.say('Directory kept.'); config_menu(:backups) }
					sub_menu.choice('Change this directory') do
						response = ''
						until Dir.exist?(response) && File.writable?(response)
							response = @cli.ask("Please enter a new directory.\n> ")
							if not Dir.exist?(response)
								@cli.say('Error - This dirctory does not exist. Try again.')
							elsif not File.writable?(response)
								@cli.say('Error - This dirctory cannot be written to. Check permissions and try again.')
							end
						end
						config['backup_directory'] = response
						File.write(config_file, config.to_yaml)
						@cli.say('Changes saved successfully.')
						config_menu(:backups)
					end
				end
			end
			menu.choice('Backup History') do
				@cli.choose do |sub_menu|
					sub_menu.prompt = "Please select a menu option\n> "
					@cli.say("=== SBCP Backup History Setting ===")
					@cli.say('Backups are currently set to remain archived for:')
					@cli.say(config['backup_history'].to_s + ' days')
					sub_menu.choice('Keep this setting') { @cli.say('Setting kept.'); config_menu(:backups) }
					sub_menu.choice('Change this setting') do
						until response > 0
							response = @cli.ask("Enter a new value in days (enter 0 to disable backups)\n> ", Integer)
							@cli.say('Value must be greater than zero.') if not response > 0
						end
						config['backup_history'] = response
						File.write(config_file, config.to_yaml)
						@cli.say('Changes saved successfully.')
						config_menu(:backups)
					end
				end
			end
			menu.choice('Backup Schedule') do
				@cli.choose do |sub_menu|
					sub_menu.prompt = "Please select a menu option\n> "
					@cli.say("=== SBCP Backup Schedule Setting ===")
					@cli.say('The backup schedule is currently set to:')
					config['backup_schedule'].is_a?(Integer) ? @cli.say('Every ' + config['backup_schedule'].to_s + ' hours') : @cli.say(config['backup_schedule'].to_s)
					sub_menu.choice('Keep this setting') { @cli.say('Setting kept.'); config_menu(:backups) }
					sub_menu.choice('Change this setting') do
						response = @cli.ask("Enter a new value in hours (enter 0 for on restart)\n> ", Integer) { |q| q.in = [0, 1, 2, 3, 4, 6, 8, 12, 24] }
						response = 'restart' if response == 0
						response = 'hourly' if response == 1
						response = 'daily' if response == 24
						config['backup_schedule'] = response
						File.write(config_file, config.to_yaml)
						@cli.say('Changes saved successfully.')
						config_menu(:backups)
					end
				end
			end
			menu.choice('Back to Main Menu') { config_menu(:main) }
		end
	when :logs
		@cli.choose do |menu|
			menu.prompt = "Please select a menu option\n> "
			@cli.say("=== SBCP Log Settings ===")
			menu.choice('Log Directory') do 
				@cli.choose do |sub_menu|
					sub_menu.prompt = "Please select a menu option\n> "
					@cli.say("=== SBCP Log Directory Setting ===")
					@cli.say('Your current logs directory is:')
					@cli.say("\"#{config['log_directory']}\"")
					sub_menu.choice('Keep this directory') { @cli.say('Directory kept.'); config_menu(:logs) }
					sub_menu.choice('Change this directory') do
						response = ''
						until Dir.exist?(response) && File.writable?(response)
							response = @cli.ask("Please enter a new directory.\n> ")
							if not Dir.exist?(response)
								@cli.say('Error - This dirctory does not exist. Try again.')
							elsif not File.writable?(response)
								@cli.say('Error - This dirctory cannot be written to. Check permissions and try again.')
							end
						end
						config['log_directory'] = response
						File.write(config_file, config.to_yaml)
						@cli.say('Changes saved successfully.')
						config_menu(:logs)
					end
				end
			end
			menu.choice('Log History') do
				@cli.choose do |sub_menu|
					sub_menu.prompt = "Please select a menu option\n> "
					@cli.say("=== SBCP Log History Setting ===")
					@cli.say('Logs are currently set to remain archived for:')
					@cli.say(config['log_history'].to_s + ' days')
					sub_menu.choice('Keep this setting') { @cli.say('Setting kept.'); config_menu(:logs) }
					sub_menu.choice('Change this setting') do
						until response >= 1
							response = @cli.ask("Enter a new value in days\n> ", Integer)
							@cli.say('Value must be greater than or equal to one.') if not response >= 1
						end
						config['log_history'] = response
						File.write(config_file, config.to_yaml)
						@cli.say('Changes saved successfully.')
						config_menu(:logs)
					end
				end
			end
			menu.choice('Log Style') do
				@cli.choose do |sub_menu|
					sub_menu.prompt = "Please select a menu option\n> "
					@cli.say("=== SBCP Log Style Setting ===")
					@cli.say('The log style is currently set to:')
					@cli.say(config['log_style'])
					sub_menu.choice('Keep this setting') { @cli.say('Setting kept.'); config_menu(:logs) }
					sub_menu.choice('Change this setting') do
						response = @cli.ask("Enter a style name (daily, restart))\n> ") { |q| q.in = ['daily', 'restart'] }
						config['log_style'] = response
						File.write(config_file, config.to_yaml)
						@cli.say('Changes saved successfully.')
						config_menu(:logs)
					end
				end
			end
			menu.choice('Back to Main Menu') { config_menu(:main) }
		end
	when :restarts
		@cli.choose do |menu|
			menu.prompt = "Please select a menu option\n> "
			@cli.say("=== SBCP Restart Settings ===")
			menu.choice('Restart Schedule') do
				@cli.choose do |sub_menu|
					sub_menu.prompt = "Please select a menu option\n> "
					@cli.say("=== SBCP Restart Schedule Setting ===")
					@cli.say('The restart schedule is currently set to:')
					config['restart_schedule'].is_a?(Integer) ? @cli.say('Every ' + config['restart_schedule'].to_s + ' hours') : @cli.say(config['restart_schedule'].to_s)
					sub_menu.choice('Keep this setting') { @cli.say('Setting kept.'); config_menu(:restarts) }
					sub_menu.choice('Change this setting') do
						response = @cli.ask("Enter a new value in hours\n> ", Integer) { |q| q.in = [0, 1, 2, 3, 4, 6, 8, 12, 24] }
						response = 'none' if response == 0
						response = 'hourly' if response == 1
						response = 'daily' if response == 24
						config['restart_schedule'] = response
						File.write(config_file, config.to_yaml)
						@cli.say('Changes saved successfully.')
						config_menu(:restarts)
					end
				end
			end
			menu.choice('Back to Main Menu') { config_menu(:main) }
		end
	end
end

ARGV << '-h' if ARGV.empty? # Displays help if no arguements given.
@cli = HighLine.new # Initialize highline object
begin o.parse!
rescue OptionParser::MissingArgument => e
	puts e
	puts 'Please provide an arguement.'
	puts "Example: sbcp #{e.to_s.split(' ').last} <arg>"
rescue OptionParser::InvalidArgument => e
	puts e
	flag = e.to_s.split(' ')[2]
	case flag
	when '-k'
		puts 'Please provide uuid, name, or ip as an arguement.'
		puts "Example: sbcp #{flag} uuid"
	when '-b'
		puts 'Please provide uuid, name, or ip as an arguement.'
		puts "Example: sbcp #{flag} name"
	when '-u'
		puts 'Please provide uuid, name, or ip as an arguement.'
		puts "Example: sbcp #{flag} ip"
	when '-l'
		puts 'Please provide bans, connections, or logs as an arguement.'
		puts "Example: sbcp #{flag} bans"
	when '-B'
		puts 'Please provide starbound, sbcp, or full as an arguement.'
		puts "Example: sbcp #{flag} starbound"
	end
rescue OptionParser::InvalidOption => e
	puts e
	puts o 
	exit 1
end